---
title: Java虚拟机内存区域和对象
date: 2017-11-15 23:03:41
tags:
categories: Java
---

来源：《深入理解Java虚拟机(第2版)》

### 运行时数据区域

根据《Java虚拟机规范(SE 7)》的规定，Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不用的区域。

<!--more-->

#### 程序计数器

程序计数器可以看作当前线程所执行的字节码的行号指示器，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令，因此，为什么线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，它们互不影响，存储在线程私有内存区域。此区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

#### Java虚拟机栈

和程序计数器一样，Java虚拟机栈也是线程私有的，每一个Java方法执行的时候，都会创建一个栈帧，用于存储局部变量，操作数栈，动态链接，方法出口地址等，此区域可能会抛出StackOverFlow异常和OutOfMemoryError异常。

#### 本地方法栈

和Java虚拟机栈的作用类似，为Native方法服务，线程私有。

#### Java堆

Java堆是被所有的线程共享的一块内存区域，此区域的唯一目的就是存放对象实例，几乎所有的对象实例和数组都会在这里分配。Java堆是GC管理的主要区域。由于现在GC基本都采用分代收集算法，所以Java堆还可以细分为新生代和老年代；再细致点就是Eden，From Survivor,To Survivor空间等。可以通过-Xmx和-Xms来进行大小的扩展。

#### 方法区

方法区也是被所有线程共享的内存区域，它用于存储已经被虚拟机加载的类信息，常量，静态变量等。

#### 运行时常量池

方法区的一部分

#### 直接内存

直接内存并不是虚拟机运行时数据区的一部分。它使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免了在Java堆和Native堆中来回复制数据。虽然直接内存的分配不受Java虚拟机的限制，但是它仍然受到物理内存总大小等的限制，当Java堆过大的时候，可能会导致这块区域分配不足而OutOfMemory异常。

![jvm_memory_1](Java虚拟机内存区域和对象/jvm_memory_1.png)

`图片来源于http://gityuan.com/2016/01/09/java-memory/`

---

### 虚拟机对象

#### 对象的创建

- 当虚拟机遇到一条new指令时，首先会去检查这个类的符号引用是否可以在常量池中定位，这个类是否已经被加载解析和初始化过。
- 检查通过后，虚拟机开始为新生的对象分配内存。分配内存通常有两种方式：
  - 如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，这种分配方式称为“指针碰撞”。
  - 如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，虚拟机就必须维护一个列表，记录那些内存块是可用的， 这种分配方式成为“空闲列表”。采用哪种方式和虚拟机的GC类型有关。
- 内存分配完成后。虚拟机需要将这块内存空间初始化为零值。此时一个新的对象已经诞生了，然后是执行<init>方法，按照程序员的意愿进行初始化，之后才可用。

#### 对象的内存布局

对象在内存中存储的布局可以分为三块区域：对象头，实例数据和对齐填充。

- 对象头包含两部分信息，一部分用来存储对象自身的运行时数据,包括对象的哈希码，gc分代年龄，锁状态标识，线程锁等，称为Mark Word（在32bit和64bit虚拟机上长度分别为32bit和64bit）；另一部分是类型指针，指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，并不是所有的虚拟机实现都必须在对象数据上保留类型指针。另外，如果对象是一个Java数组，那么对象头重还会记录数组的长度。
- 实例数据是对象真正存储信息的地方,也是代码中所定义的各种类型的字段内容.无论是继承下来的,还是子类中定义的,都需要记录起来.
- 对齐填充并不是必然存在的，因为虚拟机要对对象的大小必须是8的整数倍，因此，它仅仅用来对齐。

#### 对象的访问定位

Java程序需要通过栈上的引用数据来操作堆上的具体对象。对象的访问方式取决于虚拟机实现，目前主流的访问方式有使用句柄和直接指针两种。

句柄，可以理解为指向指针的指针，维护指向对象的指针变化，而对象的句柄本身不发生变化；指针，指向对象，代表对象的内存地址。

- 句柄 

Java堆中划分出一块内存来作为句柄池，引用中存储对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。 

优势：引用中存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而引用本身不需要修改。

![](Java虚拟机内存区域和对象/616953-20160226155344349-887482013.png)

- 直接指针

如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而引用中存储的直接就是对象地址。优势：速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。（例如HotSpot）

![](Java虚拟机内存区域和对象/616953-20160518141733169-1486000631.png)